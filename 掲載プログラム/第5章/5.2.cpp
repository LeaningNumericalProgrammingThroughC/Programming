#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define N   7             /* 次元数 */
#define EPS  1e-10        /* 収束判定用 */
#define MAX_ITER   300    /* 最大反復回数 */

// 最大値ノルム--------------------------------------------------------------
double vector_norm_max(double a[], int n){

    int i;

    double max = 0;
    for (i = 0; i < n; i++) {
        if (max < fabs(a[i])) {
            max = fabs(a[i]);
        }
    }

    return max;
}

// SOR法---------------------------------------------------------------------
void sor(double a[][N], double b[], double x[]) {

    double x_new[N], omega = 1.1, s, eps;
    int i, j, iter = 0;

    do {

        // 近似解の更新-----------------------------------------------
        for (i = 0; i < N; i++) {

            s = 0.0;
            for (j = 0; j < i; j++) {

                s += a[i][j] * x_new[j];
            }

            for (j = i + 1; j < N; j++) {

                s += a[i][j] * x[j];
            }
            x_new[i] = (b[i] - s) / a[i][i];

            // ガウス・ザイデル法の修正量をω倍する
            x_new[i] = x[i] + omega * (x_new[i] - x[i]);
        }

        // 近似解の修正量を求める--------------------------------------
        for (i = 0; i < N; i++)  x[i] = x_new[i] - x[i];
        eps = vector_norm_max(x, N);

        // 反復回数の上限か確認----------------------------------------
        if (iter >= MAX_ITER) {
            printf("収束しませんでした\n");
            exit(1);
        }

        // 次の反復計算のためにx_newの値をxに戻す----------------------
        for (i = 0; i < N; i++)  x[i] = x_new[i];

        iter++;

    } while (eps > EPS);

    // 結果の表示------------------------------------------------------
    printf("解は以下の通り\n反復回数：%d回\n", iter);
    for (i = 0; i < N; i++) {
        printf("x[%d] = %lf\n", i, x[i]);
    }
}

// メイン関数----------------------------------------------------------------
int main() {

    double a[N][N] = {
        {  8.0,  2.0,  0.0,  1.0,  3.0,  0.0,  1.0 },
        {  2.0,  6.0,  2.0,  0.0,  1.0,  0.0,  0.0 },
        {  0.0,  2.0,  8.0,  2.0,  0.0,  3.0,  0.0 },
        {  1.0,  0.0,  2.0, 10.0,  2.0,  0.0,  3.0 },
        {  0.0,  1.0,  0.0,  1.0,  5.0,  2.0,  0.0 },
        {  0.0,  0.0,  1.0,  1.0,  1.0,  4.0,  0.0 },
        {  4.0,  3.0,  0.0,  1.0,  0.0,  2.0, 11.0 }
    };
    double x[N] = { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 };
    double b[N] = { 3.0, 1.0, 4.0, 0.0, 5.0, 1.0, 6.0 };

    sor(a, b, x);

    return 0;
}

